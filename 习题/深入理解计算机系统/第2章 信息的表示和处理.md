# 第2章 信息的表示和处理

## 2.1
A.1110011010011111111000  
B.C97B  
C.11010101111001001100  
D.26E7B5

## 2.2
见书上

## 2.3
见书上

## 2.4
见书上

## 2.5
见书上

## 2.6
A.整数：0000 0000 0011 0101 1001 0001 0100 0001  
浮点数：0100 1010 0101 0110 0100 0101 0000 0100  
B.`00000000001101011001000101000001`  
.`   01001010010101100100010100000100`  
有21位重合  
C.浮点数的前面部分不重合

## 2.7
61 62 63 64 65 66

## 2.8
见书上

## 2.9
见书上

## 2.10
见书上

## 2.11
A.k+1和k+1  
B.此时first和last指向的数据地址相同，异或交换过程中会把其清为0  
C.在`inplace_swap`中加入一行判断地址是否相同，如果相同则不需要执行交换操作。

## 2.12
A.`x & 0xFF`  
B.`x ^ (~0) ^ 0xFF`  
C.`x | 0xFF`

## 2.13
`bis(x,y)`,`bis(bic(x, y), bic(y, x))`

## 2.14
见书上

## 2.15
`!(x^y)`

## 2.16
见书上

## 2.17
见书上

## 2.18
见书上

## 2.19
见书上

## 2.20
见书上

## 2.21
见书上

## 2.22
见书上

## 2.23
见书上

## 2.24
见书上

## 2.25
见书上


## 2.26
见书上

## 2.27
```cpp
int uadd_ok(unsigned x, unsigned y) {
    unsigned r = x + y;
    return r > x && r > y;
}
```

## 2.28
见书上

## 2.29
见书上

## 2.30
```cpp
int tadd_ok(int x, int y) {
    int sum = x + y;
    if (x > 0 && y > 0 && sum < 0) return 0;
    if (x < 0 && y < 0 && sum > 0) return 0;
    return 1;
}
```

## 2.31
见书上

## 2.32
见书上

## 2.33
见书上

## 2.34
见书上

## 2.35
0). $x=0$ 时，乘积$p=0$，返回`true`，函数功能正常。  
1). 记 $M = x \times y$，必然有 $M = p + t2 ^ w$。当 $x\times y$ 未发生计算溢出时，$M = p$，自然有 $t = 0$。当 $x\times y$发生计算溢出时，根据补码计算时截断的特性，有 $p \equiv M \pmod{ 2^w}$，所以有$t \neq 0$  
2).由带余除法知存在 $r, q$ 使得 $p = x \times q + r$，且 $|r| < |x|$  
3).$q=y$ 和 $r=t=0$之间互推是平凡的，下面证明当 $r$ 或 $t$ 不为 $0$ 时无法推出 $q=y$  
当 $r\neq 0$ 时，$p = x \times y - t2^w = x\times q + r,x \times(y-q) = t2^w+r$，若 $y = q$，则有 $r = t2^w$，由于 $r\neq 0$，故 $t\neq 0$，则 $r \ge 2^w$，这与 $|r| < |x|$ 矛盾。  
当 $t\neq 0$时，与上述推理类似可知无法得出 $y=q$。

## 2.36
```cpp
int tmult_ok(int x, int y) {
    int64_t mul = (int64_t) * x * y;
    return mul == (int)mul;
}
```

## 2.37
A).保证了乘法运算的时候不会发生乘法溢出，但由于调用`malloc`的时候发生类型转化，依然会溢出，所以这样改变无任何用处。  
B).应该先检查乘法运算是否会溢出，因为超过`32`位限制的内存分配本身是无意义的。若发现需要分配的内存大小超过限制，直接返回`NULL`。  

## 2.38
`a`的任意2的次幂倍数和$a \times 2 ^ k + a$

## 2.39
见书上

## 2.40
见书上

## 2.41
见书上

## 2.42
```cpp
int div16(int x) {
    return (x + (x >> 31) & 15) >> 4;
}
```

## 2.43
见书上

## 2.44
A.当 $x = -2147483648$ 时为假。  
B.始终为真。当 $x$ 的低三位不全为 $1$ 时，前一个条件为真。当 $x$ 的低三位全为 $1$ 时，前一个条件为假，但后面 $x << 29$ 必然保证最高位符号位为 $1$，故为负数。    
C.当 $x = 50000$ 时为假。  
D.始终为真。当 $x$ 为负数时，前一个条件为真。当 $x$ 非负数时，$-x$ 为非正数，后一个条件为真。  
E.当 $x = -2147483648$ 时为假。  
F.始终为真。整数加法与是否是补码无关，均遵循相同的加法原则，判断时会均转化为无符号进行比较，而在进行有无符号转化的时候，二进制表示不变，故始终为真。  
G.取 $x = 1, y = -1$，此时 $x * \backsim y + uy * us = 4294967295$，表达式不成立
# 第三次作业

## 3.3
设 $F[i][j]$ 表示考虑前 i 个货柜，选择了的货柜的长度之和为 j 的最大收益，状态转移方程为

$$\begin{aligned}
F[0][j] &= 0\\
F[i][j] &= \max(F[i-1][j-D[i]]+V[i], F[i-1][j])
\end{aligned}
$$

另计 $P[i][j]$ 标记 $F[i][j]$ 是由 $F[i-1][j]$ 还是由 $F[i-1][j-D[i]]$ 转移过来的，前者记为 0，后者记为 1。

伪代码描述如下

```plain
solve(lengths, values, D):
n <- sizeof(lengths)
//开始递推
F <- array[n+1][D], initialize 0
P <- array[n+1][D], initialize 0
for i in 1..n:
	for j in 0..D:
		F[i][j] <- F[i-1][j];
		if j >= lengths[i] and F[i-1][j-lengths[i]] + value[i] > F[i][j]:
			F[i][j] <- F[i-1][j-lengths[i]] + values[i];
			P[i][j] <- 1;
//找到最优解并构造答案
Ans <- 0;
for i in 1..D:
	if F[n][Ans] < F[n][i]:
		Ans <- i;
chosen <- empty vector
tmp <- Ans
for i in n..1:
	if P[i][tmp] == 1:
		chosen.push(i);
		tmp <- tmp - lengths[i];
return Ans, chosen;
```

算法的最坏时间复杂度为 $O(nD)$

## 3.6
设 $F[i][j]$ 表示使用前 i 种面额能否凑出 j 元，有如下递推方程

$$\begin{aligned}
F[i][0] &= true\\
F[0][j] &= false\\
F[i][j] &= F[i-1][j] \vee F[i-1][j-x_i]
\end{aligned}
$$

算法思想为：依次考虑每一种面值，当前考虑到第 i 个面值，若前 i-1 种面值能够凑出 j 元，那么加上当前这种面值就能新凑出 $j+x_i$ 元。最坏时间复杂度为 $O(nM)$

## 3.12
首先将 n 翻倍，破环成链，新增加的编号为 $n+i$ 的点的所有信息与 $i$ 保持一致，然后在这样一个序列上作动态规划。  
注意到权值的计算方法，最外圈的每条边都只会出现在唯一的三角形中，故只需计算一次，内部的三角形边都会计算两次，所以最小化目标等价于最小化中间选择的边的权值之和。  
设 $F[l][r]$ 为将区间 $[l, r]$ 对应点全部划分为三角形，所选择的边的最小权值之和。  
首先考虑边界情况，由于三角形的边有三条，所以对于 $r-l\le2$ 的区间，这一部分的权值之和就是 0。  
然后考虑递推，注意到在最后的划分中，不可能有相邻的两个点同时没有任何边连出去（否则就会出现一个边数大于等于 4 的多边形），所以编号为 l 和 l+1 的两个点中必然有一条边连到后面，所以我们考虑枚举这条边递推，每次确定一条边之后就会将问题划分为更小的两个问题，有如下递推方程。

$$F[l][r] = \min\lbrace\begin{aligned}
 &F[l][j]+F[j][r]+d_{l,j} \quad j\in[l+1, r-1] \\
 &F[l][j]+F[j][r]+d_{l+1,j} \quad j\in[l+2, r-1]
\end{aligned}$$

最后再考虑从序列上的问题恢复到环上的问题，由于只需要枚举第一次分割的边就可以将环上的问题划分为两个序列上的问题，所以考虑枚举第一条边 $[l_0,r_0]$，那么组合出的答案就是 $d_{l_0, r_0}+F[l_0, r_0]+F[r_0, l_0+n]$，枚举所有可能取最小值即可。  
至于构造方案，在递推方程的时候记录最优解是由何种分割方式推来即可。   
时间复杂度分析：序列上递推的时间复杂度为 $O(n^3)$，最后构造环上答案的复杂度为 $O(n^2)$，故总复杂度为 $O(n^3)$

## 3.15
首先记 Sum[l][r] 表示从 l 到 r 连续工作的能完成的任务数总和，其定义式为 $Sum[l][r]=\sum _{i=l}^r \min(S[i], x_i)$，采用递推的方式计算可以做到时间复杂度 $O(n^2)$  
设 $F[i]$ 表示前 i 天中，第 i 天机器在工作的最多能加工的任务数。首先注意到有最后一天一定是在工作的，否则假设最后一天检修，由于每一个 s 均是正数，最后一天不检修继续工作肯定比检修能加工更多的任务。其次一定不会有连续的两天都在检修，否则可以将前一天检修变成工作一定不会使得答案更差。  
考虑递推方程，对于边界情况，我们可以认为在第 0 天作了一次检修。对于 i 之前的某一天 j，机器工作到了 j 然后检修一天，再工作 $j-i-1$ 天，所以有递推方程

$$\begin{aligned}
F[0]&=0\\
F[i]&=\max(Sum[1][i], F[j]+Sum[j+2][i]) \quad j\in[0, i-2]
\end{aligned}$$
在递推的同时记录最优解是由具体的哪个情况转移过来即可反向推出方案。  
时间复杂度：$O(n^2)$

## 3.17
设 $F[i][j]$ 表示走到 $(i, j)$ 这个位置时最小的路径和，有如下转移方程，注意到要处理每一行的两个边界，边界只能从一个位置转移过来。

$$\begin{aligned}
F[1][1]&=a[1][1]\\
F[n][1]&=F[n-1][1]+a[n][1]\\
F[n][n]&=F[n-1][n-1]+a[n][n]\\
F[i][j]&=\min(F[i-1][j-1], F[i-1][j])+a[i][j]
\end{aligned}$$

再记录每一个 $F[i][j]$ 最优解转移的来源，即可反过来构造最优路径。

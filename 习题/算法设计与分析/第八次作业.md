# 第八次作业

## 8.2
(1). 注意到多项式可以变化为 $P(x)=(\dots((a_nx+a_{n-1})x+a_{n-2})x+a_{n-3})\dots)x+a_0$，这样我们从最里面的括号向外依次计算，每一次计算的复杂度为 $O(1)$，总共要进行 n 次，所以最坏复杂度为 $\Theta(n)$  
(2). 注意到总共有 $O(n)$ 个多项式系数，而进行多项式求值至少要对每一个系数进行 $O(1)$ 的计算，所以其下界为 $O(n)$。  
又由(1)知存在最坏复杂度为 $\Theta(n)$ 的算法，所以任何求值算法的时间复杂度均为 $\Omega(n)$

## 8.4
不妨设 $n=pk$  
(1). 采用顺序归并，总共要进行 k-1 轮合并，其中第 i 轮合并的两个序列长度分别为 ip 和 p，对应的时间代价为 $O((i+1)p)$，整理后得总时间代价为 $O(nk)$  
(2). 设计多轮归并，每一轮将序列两两合并。在每一轮中，每一个序列都最多参与一次合并，所以一次的最坏时间复杂度为 $O(n)$；又最多有 $\log k$ 层，所以总最坏时间复杂度为 $O(n\log k)$  
(3). 考虑构造如下决策树
如果当前比较的是 $a_i, a_j$，则构造点 $(i, j)$，考虑接下来的步骤：  
如果程序结束，若 $a_i \le a_j$，则将 $(i,j)$ 的左儿子标记为输入，且为叶子；否则将 $(i, j)$ 的右儿子标记为输入，且为叶子  
否则，考虑接下来比较 $(a_p, a_q)$。若 $a_i \le a_j$，则将 $(i, j)$ 的左儿子标记为 $(p, q)$；否则将 $(i, j)$ 的右儿子标记为 $(p, q)$

按照这样的方式构造出决策树，对于任意一种合并，都能对应上从根节点走到叶子的一条路径，比较次数就是路径的长度，这意味着决策树高度代表了算法的最坏复杂度。  
考虑叶子的个数，由于是从长度为 n 的序列中划分为 k 个长度为 n/k 的有序序列，由组合数学的知识可知，叶子个数为 $t=\frac{n!}{[(n/k)!]^k}$  
又 $d \ge \lceil \log t\rceil$，故整理可得 $d\ge \Theta(n\log k)$。  
由 (2) 可知已经存在一个最坏复杂度为 $O(n\log k)$ 的算法，所以 $\Theta(n\log k)$ 是原问题的最坏时间复杂度下界

## 8.7
(1). 不妨设 $A[i_0]=i_0$。由于 A 中的数字两两不等且递增，所以对任意的 $i < j$，有 $A[j] - A[i] \ge j-i$，那么对于 $i < i_0$，均有 $A[i] \le i$，对于 $i > i_0$，均有 $A[i] \ge i$。这意味着 $A[i]-i$ 是一个单调不降的序列，问题转化为寻找 $A[i]-i=0$ 的 i，由单调性知可以二分，算法代码描述如下：

```python
function geti0(A):
l <- 1
r <- len(A)
while l <= r:
    mid <- (l + r) / 2
    if A[mid] == mid:
        return mid
    elif A[mid] < mid:
        l = mid + 1
    else:
        r = mid - 1
```

最坏的时间复杂度：while 循环一直进行到最后一次（即 l==r），由于题目保证这样的 $i_0$ 一定存在，所以一定能找到。由二分的时间复杂度知，while 循环体内容最多执行 $\log n$ 次，每次循环体内部的时间复杂度为 $\Theta(1)$， 故最坏时间复杂度为 $\Theta(\log n)$  
(2). 构造决策树如下：
设当前判定点为第 i 个数，记为节点 $i$，考虑接下来的步骤：  
若 $A[i]==i$ ，则算法结束，将 i 标记为叶子节点  
若 $A[i] < i$，接下来判定点为 j ，则将 j 标记为 i 的左儿子  
若 $A[i] > i$，接下来判定点为 j，则将 j 标记为 i 的右儿子  
这样构造使得任意一种算法都能对应决策树上从根到叶子的一条路径，决策树高度就是算法的最坏时间复杂度。  
注意到决策树最多有 $n$ 个节点，故决策树树高 $d \ge \log n$，故最少需要 $\Omega(\log n)$ 次比较。

## 8.10
首先注意到，找第 k 小与找第 n-k+1 大是等价的，这同时意味着找第 k 小和找第 n-k+1 小是可以等价转换的，所以若时间复杂度中有关于 $k$ 的项，可以考虑用 $n-k+1$ 代替 k 是否能得到更优的结果，故在下面的讨论中，先仅讨论 $k \le n-k+1$ 即 $k \le \lceil n/2 \rceil$ 的情况。对于任意一个求第 k 小的算法，下面构造达到最坏复杂度的数据。  
不妨设第 k 小的数为 p，首先给 p 任意赋值，然后根据算法 A 依次进行的比较如下构造，不妨设算法 A 本次比较的数为 x, y：  
1.a. 若 x, y 均未赋值，则将 x 赋值为小于 p 的数，将 y 赋值为大于 p 的数  
1.b 若 x 已赋值且 x < t，则将 y 赋值为大于 p 的数（同理若 y 已赋值且 y < t，则将 x 赋值为大于 p 的数）  
1.c 若 x 已赋值且 x > t，则将 y 赋值为小于 p 的数（同理若 y 已赋值且 y > t，则将 x 赋值为小于 p 的数）  
2. 若已经存在 k-1 个元素小于 p ，则将剩下未赋值的元素中的一个赋值为 p ，其余的赋值为大于 p 的元素（同理，若已经存在 n-k 个元素大于 p，则将剩下未赋值的元素中的一个赋值为 p，其余的赋值为小于 p 的元素）

构造正确性：注意到，如果要确定第 k 小的数 p 的确是第 k 小，那么这个数需要直接或间接地与其余 n-1 个数各进行一次比较，称这 n-1 次比较为有意义比较，其余的比较称为无意义比较。这个比较的意思是，要么这个数直接与 p 进行了比较，要么这个数与一个已经与 p 确定大小关系的数进行了比较且比较结果方向相同（即若已经确定 y < p，现在比较 x 与 y 确定了 x < y，则是有意义的，反之亦然）。而在上面的构造中，前 k-1 次比较对于确定第 k 小的均是无意义的，这意味着有意义比较出现在 k-1 次比较之后。而有意义的比较固定是 n-1 次，所以总的比较次数至少是 $k-1 + n-1=n+k-2$。再将 $k > n-k+1$ 的另外一般情况考虑进来，即可得到总的比较次数至少为 $n-2 + \min(k, n-k+1)$。

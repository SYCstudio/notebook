# 第二次作业

## 2.7
(1).将 A 排序后，$\Theta(n)$ 地扫描整个数列找到所有极长连续相等的区间，若其中最长的区间长度大于 n/2 则说明存在主元素。  
排序部分复杂度为 $O(n\log n)$，故总复杂度为 $O(n\log n)$  
(2). 类似 $O(n)$ 求第 k 大的算法，选择一个元素 x 然后将小于该元素的移动到其左边，大于等于该元素的移动到其右边，若其中有一边长度超过 n/2 且全部相同则说明存在主元素，否则若其中有一边长度超过 n/2，则递归这一边，否则若两边长度都不足 n/2 则说明不存在主元素。  
由求第 k 大算法同样的分析可知，复杂度为 $O(n)$  
(3). 算法内容：设定两个变量 x 和 cnt，初始时 x 为一个不存在 A 中的数 sp ，cnt 为 0。从前往后扫描数组中的每一个元素 a，分情况讨论：若 x 为 sp，则将 x 赋值为 a，cnt 置为 1；若 x 不为 sp 且 x == a，则 cnt = cnt + 1；若 x 不为 sp 且 x != a，则 cnt = cnt - 1，若 cnt 计算完之后为 0 则将 x 置为 sp。这样进行完之后，若 x == sp 则说明不存在主元素；否则检查 x 在 A 中出现的次数，若超过 n/2 次则为主元素，否则也不存在主元素。  
正确性：若 A 中存在主元素 x，这意味着 x 在 A 中至少出现了 $\lfloor \frac n 2\rfloor + 1$ 次，而每一个非 x 的数最多抵消掉一个 x，所以最后剩下的一定是 x；而同时在最后进行了 x 的检查，所以正确性成立。  
最坏复杂度：O(n)

## 2.12
将 B 排序，然后对 A 中每个元素在 B 中二分查找，复杂度为 $O(m\log m) + O(n\log m)=O(n\log\log n)$，伪代码如下

```plain
C <- an empty set
 B' <- sorted B
for each element x in A:
    if (binary_search x in B) C.insert(x)
return C
```

## 2.15
(1). 算法 A：每次调用 `findmax` 的最坏复杂度为 $O(n)$，那么最坏复杂度为 $\sum_{i=1}^{\sqrt n}(n-i)=O(n\sqrt n)$  
算法 B：排序复杂度为 $O(n\log n)$，寻找前 $i$ 大为 $O(i)$，故最坏复杂度为 $O(n\log n)$  
(2). 算法过程：抽象方法 `find(A, k)` 为寻找 A 中最大的 k 个数，在 A 中任选一个数 x ，将小于 x 的移动到 x 前面，大于 x 的移动到 x 后面，这样将 A 划分为左右两个集合 Al, Ar。若 Ar 大小恰好为 k 或恰好为 k-1，则说明已经找到最大的 k 个，过程返回；否则，记 |Ar| 为 Ar 大小，递归调用 `find(Al, k - |Ar| - 1)`。递归全部返回后，数组的后 k 项恰好就是最大的 k 个数，对这 k 个数进行排序即可。  
最坏复杂度：递归部分复杂度为 $O(n)$，排序部分复杂度为 $O(\sqrt n\log \sqrt n) = O(\sqrt n \log n)$，故总复杂度为 $O(n)$

## 2.16
(1). $O(n)$ 找出 S 中的最大值和最小值，分别就是 x, y。  
(2). $O(n\log n)$ 对 S 排序，$O(n)$ 扫描 S 找出相邻的距离最近的一对数即为 x, y。

## 2.18
$O(n)$ 求出每个点到原点的距离，然后调用 2.15(2) 中算法找出最小的 $\sqrt n$ 个，复杂度为 $O(n + \sqrt n\log n) = O(n)$

## 2.23
找到第 $\lfloor \frac n 2 \rfloor$ 大的数 x，判断 x 是否满足近似中值条件，若满足则已经找到；否则，找出比 x 小的最大的数 x1 和比 x 大的最小的数 x2，判断 x1, x2 其中之一是否满足近似中值条件，若满足则已经找到，否则说明不存在近似中值。  
正确性：若第 $\lfloor \frac n 2\rfloor$ 大的数 x 已经是近似中值，则正确性显然；否则 x 必然在“小于 x 的数的个数 $\ge \frac n 4$” 和 "大于 x 的数的个数 $\ge \frac n 4$" 中至少一个不满足（为便于描述，下面将这两个条件分别成为小于条件和大于条件）。不妨假设是小于条件不满足，那么这意味着比 x 更小的数都不可能成为近似中值，仅需要考虑 x2。对于 x2，小于条件是成立的，而若大于条件也成立，则说明 x2 是近似中值，否则说明 x2 不满足大于条件，这意味着比 x2 更大的数也不满足大于条件，此时小于等于 x 的数均不满足小于条件，大于等于 x2 的数均不满足大于条件，同时 x 与 x2 之间不再有其它的数，故不存在近似中值。当 x 的大于条件不满足时，推理也是类似的。而若 x 同时不满足小于条件和大于条件，此时一定不存在近似中值。  
最坏复杂度：求中位数的最坏复杂度为 $O(n)$，找到比中位数大的最小数和比中位数小的最大数的最坏复杂度均为 $O(n)$，判断一个数是否是近似中值的最坏复杂度为 $O(n)$，故总最坏复杂度为 $O(n)$

## 2.27
目标：选择合适的$(x, y)$ 最小化 $\sum _ {i=1}^n |x-x_i|+|y-y_i|$，其中 $(x_i, y_i)$ 为第 i 个商店的位置。  
注意到 x, y 两维是互不相关的，所以可以分开考虑。问题转化为，寻找合适的 $k$，最小化 $\sum _ {i=1}^n |k-k_i|$  
由数学知识知，当 $k$ 为 $\{k_i\}$ 中位数时，和最小。故寻找的 $(x,y)$ 就分别是 $\{x_i\}$ 和 $\{y_i\}$ 的中位数。寻找中位数算法的最坏复杂度为 $O(n)$， 故最终的最坏复杂度为 $O(n)$

# 第8章 异常控制流
通常的程序控制都是按照一个序列执行若干指令，这一过程被称为**控制流**。但偶尔也需要使控制流发生突变以应对某些特殊情况，这些突变称为**异常控制流**。  
异常控制流可以发生在计算机的各个层次。在硬件层，硬件检测到某些事件会立刻将控制转移到异常处理程序；在操作系统层，内核通过上下文切换将控制从一个进程转移到另一个进程；在应用层，进程可以发送信号到另一个进程，接受信号的进程会立即转移到对应的信号处理程序；在应用程序，程序可以回避栈的调用原则，跳转到其它函数中的任意位置来对错误作出反应。

## 进程
进程是一个执行中的程序的实例，系统中的每个程序都运行在某个进程的**上下文**中。上下文指的是程序运行所需的各种状态，包括存放在内存中的程序代码和数据、程序的栈、寄存器内容、程序计数器、环境变量等。当用户通过 `shell` 运行一个新的程序时，就会创建一个新的进程，并在新进程的上下文中运行。  
进程提供给应用程序两个抽象：独立的逻辑控制流（即好像程序独占处理器），私有的地址空间（即好像程序独占内存系统）。

### 逻辑控制流和并发流
程序运行时 PC 值变化的序列被称为**逻辑控制流**或简称**逻辑流**。实际上，进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被**抢占**，轮到其它进程执行。  
当一个逻辑流的执行在时间上与另一个流重叠时，称为**并发流**，称两个流并发地运行。多个流同时执行地现象被称为并发。  
并发流与流运行的处理器核数或机器数无关。若两个流并发地运行在不同的处理器核或机器上。则称为**并行流**，并行流是并发流的子集。

### 用户模式和内核模式
这一机制用于限制应用可以执行的指令集以及可以访问的地址空间范围。用户模式不允许执行一些特权指令，也不允许直接引用地址中内核区的代码和数据。用户需要调用系统提供的接口来间接地访问内核代码和数据，这一机制即使异常。当异常发生时，控制传递给异常处理程序，同时处理器从用户模式切换到内核模式，执行相关内容，最后返回时再切换回用户模式。  
在处理器设计中，通常提供了**模式位**来区分两个模式。当设置了模式位时，进程就运行在内核模式，否则在用户模式。  
Linux 系统提供了 `/proc` 文件系统使用户模式进程也能访问内核数据结构中的内容，这一文件系统将许多内核数据结构输出为用户可读的文本内容。

### 上下文切换
操作系统使用一种更高层的抽象——**上下文切换**——来实现多任务和各种异常机制。  
内核为每一个进程维护上下文，在进程执行的某些时刻，内核可以决定抢占当前进程，并切换到一个先前被抢占的进程。这一决策被称为**调度**，由内核中的**调度器**处理。当决定抢占时，执行三个步骤：保存当前进程的上下文，恢复另一个上下文，传递控制。

## 异常
异常是控制流中的突变。这里称处理器状态发生变化为**事件**，事件可能与当前正在执行的指令有关（如内存缺页，除零错误等），也可能与当前指令无关（如定时器的信号，I/O请求完成等）。  
当处理器检测到有事件发生时，会通过**异常表**进行跳转，进行一个间接过程调用，执行一个专门处理该事件的异常处理程序。当异常处理程序结束后，可能会返回原来正在执行的指令，也可能返回原来指令的下一条指令，还有可能直接中断程序。  
系统中每一种可能的异常都分配了一个唯一的编号。由于异常机制是由硬件和操作系统共同实现的，这里编号的定义也分别由处理器和操作系统负责分配。系统启动的时候，操作系统会分配并初始化称为**异常表**的跳转表，其中的条目 k 包含对应编号为 k 的异常的处理程序的地址。  
异常在一些方面类似于过程调用，但也有重要的不同：

1. 根据异常的类型，返回地址可能是当前指令，也可能是下一条指令。
2. 有时处理器会把一些额外的状态压到栈里。这是为了能在处理程序返回后，重新开始执行被中断的程序。
3. 异常处理程序运行在内核模式下，对所有的系统资源都有完全的访问权限。

### 异常的类别
异常可分为四类：中断，陷阱，故障和终止。下表是一个简单的总结。

| 类别 |       原因       | 异步/同步 |      返回行为       |
| ---- | --------------- | -------- | ------------------ |
| 中断 | 来自I/O设备的信号 | 异步      | 总是返回到下一条指令 |
| 陷阱 | 有意的异常        | 同步      | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误  | 同步      | 可能返回到当前指令   |
| 终止 | 不可恢复的错误    | 同步      | 不会返回            |

这里的异步/同步指的是是否于当前指令有关。硬件中断不是由特定的指令导致的，故是异步的。其它的异常则与当前执行的指令有关，故是同步的。

**中断**通常与各类 I/O 设备有关。这些设备通过向 CPU 的某个引脚发送信号，并把异常号放到总线上来触发中断。处理器在执行完当前指令后，首先检查引脚，发现中断引脚的电压升高（这意味着有设备发送了信号），然后从系统总线读取信号，并调用适当的中断处理程序。  
**陷阱**通常与系统调用有关，是*有意*的异常。这一异常通常用于用户程序向内核请求服务（如读写文件(read)，创建进程(fork)，加载新程序(execve)，终止当前程序(exit)）。这些是内核服务，运行在内核模式下，而普通的函数是运行在用户模式下的。陷阱为程序员提供了一种调用系统服务的便捷方法。  
**故障**由错误情况引起，处理器会尝试调用故障处理程序来进行修正，如果成功修正，则返回引起故障的指令并重新执行，否则进入 `abort` 例程终止程序。  
**终止**由不可恢复的致命错误引起，处理器会直接进入 `abort` 例程终止程序。

### Linux 中的异常实例
常见故障和终止

* 除法错误。试图除以0，或除法指令的结果对于目标操作数来说太大。不会尝试恢复，直接终止，报告为 `Floating exception`浮点异常。
* 一般保护故障。通常是程序引用了未定义的虚拟内存区域，或试图对只读文本段写。不会尝试恢复，直接终止，报告为`Segmentation fault`段错误。
* 缺页。处理程序将适当页面加载进内存，然后重新执行产生故障的指令。
* 机器检查。检测到致命的硬件错误，从不返回。

Linux 提供了几百种系统调用，下图给出了其中的一部分。与通常的函数调用类似，也使用六个寄存器包含最多六个参数（所有的系统调用都只需要通过寄存器传递参数），同时在 `%rax` 中存放系统调用号。返回时，`%rax` 中包含返回值，若返回的负数表明发生了错误。

![Linux 系统中的常见系统调用](_v_images/20211124142402329_14801.png)

#### 系统调用错误处理
系统级函数遇到错误时，通常会返回 -1，并设置全局整数变量 `errno` 记录信息。下面是一个 `fork` 检查错误的实例。

```c
if ((pid = fork()) < 0) {
    fprintf(stderr, "fork error: $s\n", strerror(errno));
    exit(0);
}
```

为了简化代码，可以将错误检查包装成同名的首字母大写函数，在下面将总是使用这种错误处理的包装函数。

## 进程控制
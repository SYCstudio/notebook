# 第4章 处理器体系结构

## `Y86-64` 指令集体系结构
### 程序员可见的状态
在 `Y86-64` 中定义有 15 个程序寄存器，每个寄存器存储一个 64 位的字。其中 `%rsp` 被用来记录入栈、出栈、调用和返回指令，作为栈指针，其它寄存器没有固定的含义。  
定义 ZF（零）,SF（符号） 和 OF（溢出） 三个一位的条件码，保存最近的算术或者逻辑信息。程序计数器 PC 存放当前正在执行指令的地址。  
使用虚拟地址来引用内存位置，即把内存认为是一个很大的字节数组。  
状态码 `Stat` 用于表明程序执行的总体状态，即是正常运行还是出现异常（如某条指令尝试读取非法的内存地址）。

![程序员可见状态](_v_images/20211004224955526_20686.png)

### `Y86-64` 指令及其编码
`Y86-64`的指令集基本上是 `x86-64` 的子集，仅包含 8 字节的整数操作。下面是一些细节。

`movq` 指令被拆成了四个不同的指令：`irmovq,rrmovq,mrmovq,rmmovq`，前缀用于显式地指出源和目的地格式：立即数`i`，寄存器`r`和内存`m`。  
内存引用方式都是简单的基址和偏移量形式。不支持第二变址寄存器和任何寄存器值的伸缩，不允许从一个内存地址直接传送到另一个内存地址，不允许将立即数直接传送到内存。  
四个整数操作指令：`addq, subq, andq, xorq`。仅支持对寄存器数据进行操作，并能设置三个条件码。  
七个跳转指令：`jmp, jle, jl, je, jne, jge, jg`。条件与 `x86-64` 中一致。  
六个条件传送指令：`cmovle, cmovl, cmove, cmovne, cmovge, cmovg`。指令格式与 `rrmovq` 一样。  
`call` 指令将返回地址入栈，并跳转到目的地址。与之相配的`ret`指令从调用中返回。  
`pushq` 与 `popq` 实现入栈和出栈。  
`hall` 指令停止指令的执行。在 `x86-64` 中，对应的指令为 `hlt`，应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。而在 `Y86-64` 中，`halt` 指令会导致处理器停止，并将状态码设置为 `HLT`。

![指令集](_v_images/20211004225427046_12551.png)

每条指令需要 1 到 10 个字节不等的空间，其中第一个字节表明指令的类型。这一字节又分为两部分：高 4 位表示代码，低 4 位表示功能。代码给出指令所在的指令组，而功能则是指出具体是该指令组中的哪一个。

![功能码](_v_images/20211004230145541_15553.png)

15 个寄存器也有对应的标识符，从 0 到 `0xE`。当需要指明不应访问任何寄存器时，用 `0xF` 来表示。

![寄存器](_v_images/20211004230405432_4632.png)

> 关于指令的补充说明：  
> 有些指令有附加的寄存器字节，称为 `rA, rB`，而只需要一个寄存器作为操作数的指令将另一个寄存器设置为 `0xF`。  
> 有些指令需要一个附加的 8 字节常数字，如 `irmovq` 的立即数数据、`rmmovq` 和 `mrmovq` 的地址指示符的偏移量以及分支指令和调用指令的目的地址。  
> 分支和调用指令的目的是一个绝对地址，而不是 `x86-64` 中的相对寻址方式。  
> 所有整数采用小端法编码。

`Y86-64` 指令集满足唯一解释。
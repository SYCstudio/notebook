# 第9章 虚拟内存

## 一些基础概念
物理内存：将 CPU 的主存组组成简单的字节数组，即为物理内存  
虚拟内存：CPU 生成虚拟地址来访问主存，这个地址在被送到内存之前先被翻译为适当的物理地址。翻译的专用硬件为**内存管理单元（MMU）**，该表的内容由操作系统管理。  
对应的有虚拟地址空间和物理地址空间，通常用 $2^N, 2^M$ 来表示大小。

虚拟内存可以形象的理解为一个存放在磁盘上的连续的 N 个的字节的数组，每个字节都有唯一的虚拟地址。

### 页
VM 系统将虚拟内存分割为大小固定的**虚拟页**，每个虚拟页大小为 $2^p$，对应的有物理内存被分割为**物理页**，大小与虚拟页一样。  
在任意时刻，虚拟页面的集合被分为三个互不相交的子集：

* **未分配的**：VM 系统还未分配或创建的页，没有任何数据与这些页相关联，因此也就不必占用磁盘空间。
* **缓存的**：已缓存在物理内存中的分配页。
* **未缓存的**：未缓存在物理内存中的分配页。

#### 页表
**页表**是存放在物理内存中的数据结构，用于将虚拟页映射到物理页。它能够支持判定某个虚拟页是否缓存在 DRAM 中的某个位置，若是还可以确定这个具体位置。  
页表是软硬件联合维护的（包括操作系统，MMU）。每次 MMU 将虚拟地址转化为物理地址时都会读取页表，而操作系统负责维护页表的内容，并负责在磁盘与 DRAM 之间传递页。

页表的每一项叫做**页表条目（PTE）**，PTE 与虚拟内存中的每个页是一一对应的。一般认为 PTE 是由一个有效位和一个 n 位地址组成的，前者标注该虚拟页是否缓存在 DRAM 中，后者记录相应物理页的起始地址。

#### 页命中与缺页
当 CPU 读取虚拟内存中的字时，若所需要的页已经在物理内存中，那么此时称**页命中**，否则称为**缺页**。  
如果发生缺页，地址翻译硬件就会触发一个缺页异常，选择一个牺牲页进行替换，然后重新启动相关指令。

## 虚拟内存
操作系统为每个进程提供了独立的页表，也就是独立的虚拟地址空间。  
将按需页面调度和独立的地址空间两种方法结合，能简化链接和加载、代码和数据共享以及应用程序的内核分配。

> 加载器将目标文件加载到进程中时，仅为其分配虚拟页，并标记为未缓存的，这意味着加载器并不从磁盘复制任何数据到内存。  
> **内存映射**能将一组连续的虚拟页银蛇到任意文件的任意位置。Linux 系统调用 mmap 允许程序自己做内存映射。  
> 在 PTE 中添加控制位能方便地控制内存的访问权限，这样可以保护内存

## 地址翻译
形式化的，地址翻译即是将虚拟地址空间的元素映射到物理地址空间中的元素。下面是一些需要用到的符号。

![地址翻译相关符号](_v_images/20211203150654719_5864.png)

CPU 中有一个**页表基址寄存器**指向当前页表，便于查找。n 位的虚拟地址包括两个部分：一个 p 位的虚拟页面偏移，和一个 n-p 位的虚拟页号，下图展示了 MMU 利用页表实现映射的过程。

![页表地址翻译](_v_images/20211203150708794_8411.png)

当 CPU 需要访问某个地址时，CPU 会将虚拟地址传递给 MMU，由 MMU 生成 PTE 地址，并从高速缓存或主存中得到，MMU 再构造物理地址传送给高速缓存或主存，将请求的字返回给处理器。若出现不命中，则调用触发异常，进行缺页处理，然后再接着执行。

> 现代系统通常使用物理寻址来访问 SRAM 高速缓存，这意味着多个进程共享和权限保护都比较好处理。

### TLB 加速地址缓存
MMU 有着自己的关于 PTE 的小缓存，被称为**翻译后备缓冲器（TLB）**。TLB 的每一行都保存着单个 PTL 的块，且有着高度的相联度。  
加入 TLB 后，与 MMU 有关的修改仅有在查询 PTE 时先在 TLB 中查询是否有需要的 PTE 项，若有则直接使用，否则向主存请求。  
所有的地址翻译步骤都是在 MMU 中执行的，因此速度非常快。

### 多级页表
在实际系统中，为节省空间，页表通常是多级的，前一级页表指向的是后一级页表在内存中的位置，而只有最后一层指向的是真正的数据地址。  
这样做在两个方面减少了内存需求：其一是，若一级页表的某一项是空的，那么对应的二级页表就不会存在，这能极大地节约空间使用；其二是，只有一级页表是常驻主存地，二级页表只需要在必要地时候创建、调入和调出，减少了主存的压力。  
当使用 k 级页表时，虚拟地址被划分为 k 个 VPN 和 1 个 VPO ，每个 VPN 负责一级页表的索引，图示如下。

![k 级页表下虚拟地址的翻译](_v_images/20211203151839052_1293.png)

TLB 能将不同层次的 PTE 缓存起来，使得多级页表的翻译速度也很快。

## 内存映射
内存映射：将虚拟内存区域与磁盘上的对象关联起来，以初始化这片虚拟内存区域的内容。虚拟内存可以映射到下面两种类型中的一种：

* 普通文件：比如可执行目标文件。当区域比文件区大时，上下的部分用 0 来填充。
* **匿名文件**：匿名文件是由内核创建的，包含的全是二进制 0 。当 CPU 第一次引用这样一个页面时，会用二进制 0 覆盖牺牲页面。注意到磁盘与内存之间并没有实际的数据传输，所以这一方法也叫做请求二进制零的页。

无论是哪种情况，一旦一个虚拟页面被初始化了，它就在一个由内核维护的**交换文件（交换空间）**中移动。在任何时候，交换空间都限制着当前运行的进程能够分配的虚拟页面的总数。

### 共享对象
一个对象可以被映射到虚拟内存的一个区域，且要么是**共享对象**，要么是**私有对象**，相应的有共享区域和私有区域。正如其定义，一个进程对共享对象的操作会影响到其它关联到这个共享对象的进程，而若修改的是私有对象则对其它是不可见的。  
这一机制能非常有效地管理多个进程的公共内容。由于每个对象都有唯一的文件名，当新的进程建立时，内核可以迅速地判定其它进程是否已经加载了新进程所需的共享内容，如果有则直接将其与对应的物理内存绑定，否则将其载入。  
对于私有对象也是类似的，这里使用的技术被称为**写时复制**，即私有对象开始时与共享对象一样，在物理内存中仅有一份副本，两个进程可以将一个私有对象映射到它们自己的虚拟内存中，且只要进程均不写这些私有区域，都会一直保持不变。而当只要有一个进程试图写这个私有区域的某个页面时，就会触发一个保护故障。保护故障的处理程序注意到这是由于进程试图写私有区域引起的，就会在物理内存中创建这个页面的新副本，并更新页表条目的相关内容。

### `fork` 函数
当 `fork` 函数被当前进程调用时，内核会为新进程创建相关的数据结构，并分配唯一的 PID。它将两个进程中每个页面标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当两个进程中任何一个在后面进行写操作时，相关机制就会创建新页面。

### `execve` 函数
运行 `execve` 函数会执行以下几个操作

1. 删除已存在的用户区域：删除当前进程虚拟地址的用户部分的已存在的区域结构。
2. 映射私有区域：为新的程序创建相关区域结构，标记为私有的、写时复制的。代码和数据区域被映射到 `.text` 和 `.data` 区，`.bss` 设置为请求二进制零区（即映射到匿名文件），栈和堆区域也是映射到匿名区域。
3. 映射共享区域：将涉及到的动态链接映射到地址空间的共享区域内。
4. 设置程序计数器：设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。

### `mmap` 函数
Linux 进程可以使用 `mmap` 函数创建新的虚拟内存区域，并将对象映射到这些区域中，该函数的定义如下：

```c
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
```

若成功则返回指向映射区域的指针，否则为 `MAP_FAILED`（值为 -1 ）。  
该函数要求内核创建一个新的虚拟内存区域，最好是从地址 `start` 开始的，并将文件描述符 `fd` 指定的对象的一个连续的片映射到这个新的区域，连续片大小为 `length` 字节，从距离文件开始偏移 `offset` 字节的地方开始。`start` 通常设置为 `NULL`。  
参数 `prot` 设置新区域内页面的访问权限位，有以下选择：

* `PROT_EXEC`：页面由可被 CPU 执行的命令组成
* `PROT_READ`：页面可读
* `PROT_WRITE`：页面可写
* `PROT_NONE`：页面不能访问

参数 `flags` 描述被映射对象类型的位组成。如果设置了 `MAP_ANON` 标记位，那么被映射的对象就是一个匿名对象；`MAP_PRIVATE` 表示被映射的对象是一个私有的、写时复制的对象；`MAP_SHARED` 则表示是一个共享对象。

与之相对的函数 `munmap` 删除虚拟内存的区域，其定义为 `int munmap(void *start, size_t length)`。

## 动态内存分配

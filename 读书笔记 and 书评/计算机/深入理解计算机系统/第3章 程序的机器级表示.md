# 第3章 程序的机器级表示

## 机器代码的一些简单操作
使用 `-S` 选项可以让 `gcc` 生成汇编代码。使用 `-C` 选项生成二进制代码文件`.o`。  
反汇编器可以根据机器代码产生类似汇编代码的格式。在 `linux` 中一般使用 `objdump`，即 `objdump -d filename`。  

> 关于及其代码及反汇编表示：
> `x86-84`的指令长度从1到15字节不等，根据使用的频繁程度赋予对应的字节长度。
> 从某个给定位置开始，字节解码成机器码是唯一的。
> 反汇编器根据机器代码中的字节序列来确定汇编代码，不需要访问源代码或原汇编代码。
> 以`.`开头的都是指导汇编器和连接器工作的伪指令，通常可以忽略。

## 数据格式与操作
称8位数据类型为字节`byte`，16位数据类型为字`word`，32位数据类型为双字`double words`，64位数据类型为四字`quad words`。  
大部分 GCC 生成的汇编代码指令都有一个字符后缀，来表示操作数的大小，如`movb,movw,movl,movq`分别传输字节、字、双字和四字。

### 寄存器
一个 `x86-64` 的中央处理单元包括一组16分存储64位值的*通用目的寄存器*，用来存储整数数据和指针。

![register](_v_images/20210922150253040_13353.png)

使用不同的指令可以操作寄存器中不同的低位字节。

> 注：当生成小于 8 字节结果的指令以寄存器作为目标时，寄存器剩下的字节会如何变化与操作数大小有关：
> 若生成的是1字节或者2字节的数，则剩下的字节保持原样。
> 若生成的是4字节的数，则会把高位的4个字节置为0。

### 操作数指示符
操作数分为三种：立即数，寄存器和内存。  
立即数用来表示常规值，其书写方式是`$`后根标准 C 表示法表示的整数。注意到不同的指令允许的立即数的范围不同，汇编器会自动选择最紧凑的方式进行编码。  
寄存器则是表示寄存器中存储的内容，用$r_a$表示任意寄存器$a$，用引用$R[r_a]$表示它的值。  
内存引用是根据计算出来的地址访问某个内存位置，在这里我们将内存看作一个很大的字节数组。  
通常用$Imm(r_b, r_i, s)$来这一通用形式来寻址。其中$Imm$表示立即数偏移，$r_b$ 是基址寄存器，$r_i$ 是变址寄存器，$s$是比例因子且只能为$1,2,4,8$，最终的地址计算为 $Imm + R[r_b] + R[r_i] \times s$。注意 $r_b$ 和 $r_i$ 都必须是 64 位寄存器。

### 数据传输指令
# 第3章 程序的机器级表示

## 机器代码的一些简单操作
使用 `-S` 选项可以让 `gcc` 生成汇编代码。使用 `-C` 选项生成二进制代码文件`.o`。  
反汇编器可以根据机器代码产生类似汇编代码的格式。在 `linux` 中一般使用 `objdump`，即 `objdump -d filename`。  

> 关于及其代码及反汇编表示：
> `x86-84`的指令长度从1到15字节不等，根据使用的频繁程度赋予对应的字节长度。  
> 从某个给定位置开始，字节解码成机器码是唯一的。  
> 反汇编器根据机器代码中的字节序列来确定汇编代码，不需要访问源代码或原汇编代码。  
> 以`.`开头的都是指导汇编器和连接器工作的伪指令，通常可以忽略。

## 数据格式与操作
称8位数据类型为字节`byte`，16位数据类型为字`word`，32位数据类型为双字`double words`，64位数据类型为四字`quad words`。  
大部分 GCC 生成的汇编代码指令都有一个字符后缀，来表示操作数的大小，如`movb,movw,movl,movq`分别传输字节、字、双字和四字。

### 寄存器
一个 `x86-64` 的中央处理单元包括一组16分存储64位值的*通用目的寄存器*，用来存储整数数据和指针。

![register](_v_images/20210922150253040_13353.png)

使用不同的指令可以操作寄存器中不同的低位字节。

> 注：当生成小于 8 字节结果的指令以寄存器作为目标时，寄存器剩下的字节会如何变化与操作数大小有关：  
> 若生成的是1字节或者2字节的数，则剩下的字节保持原样。  
> 若生成的是4字节的数，则会把高位的4个字节置为0。

### 操作数指示符
操作数分为三种：立即数，寄存器和内存。  
立即数用来表示常规值，其书写方式是`$`后根标准 C 表示法表示的整数。注意到不同的指令允许的立即数的范围不同，汇编器会自动选择最紧凑的方式进行编码。  
寄存器则是表示寄存器中存储的内容，用$r_a$表示任意寄存器$a$，用引用$R[r_a]$表示它的值。  
内存引用是根据计算出来的地址访问某个内存位置，在这里我们将内存看作一个很大的字节数组。  
通常用$Imm(r_b, r_i, s)$来这一通用形式来寻址。其中$Imm$表示立即数偏移，$r_b$ 是基址寄存器，$r_i$ 是变址寄存器，$s$是比例因子且只能为$1,2,4,8$，最终的地址计算为 $Imm + R[r_b] + R[r_i] \times s$。注意 $r_b$ 和 $r_i$ 都必须是 64 位寄存器。

### 数据传输指令
使用指令 `mov* A B` 将 A 中的内容移动到 B 中，其中 `*` 根据移动操作的大小不同进行选择。  
通常，`mov`指令只会更新目的操作数指定的寄存器字节或内存位置，但例外`movl`当以寄存器为目的时，会把该寄存器的高 4 字节设置为 0。  
`mov` 指令的两个地址不能同时是内存地址。如果需要将一个值从内存的某个位置移动到另一个，需要先使用一次`mov`加载到寄存器中，再移动到内存中。  
特殊指令`movabsq`以任意64位立即数作为源操作数，且只能以寄存器为目的。常规的`movq`指令只能以32位补码的立即数作为源操作数，然后把这个值的符号扩展到高位。  
`movz`和`movs`两类指令是在从较小的源复制到较大的目的时使用，其中`movz`把剩余的字节填充为0，而`movs`把剩余的字节填充为最高符号位。

> 并不存在`movzlq`这一指令，因为`movl`已经能将高4字节设置为 0。  
> 特殊指令`cltq`没有操作数，直接将`%eax`符号扩展到`%rax`。等价于`movslq %eax, %rax`。

### 栈操作
指令`pushq`将数据压入程序栈中，而指令`popq`从程序栈中弹出数据。这两条指令操作的都是栈指针`%rsp`。

## 算术和逻辑操作
总览

![integer operators and logic operators](_v_images/20210923164716459_18421.png)

指令`leaq`本来是用来计算内存位置的，但由于其可以简单地进行一些算术运算，所以很多时候编译器会将其用于算术。  
所有的二元操作均是以第一个操作数为源操作数，第二个操作数为目的操作数。例如`subq %rax, %rdx`的解释为：将`%rdx`中的数减去`%rax`中的数，结果存放到`%rdx`中。  
移位操作的第一个操作数`k`可以是立即数，也可以是存放在寄存器`%cl`中的数（只能为`%cl`）。当移动$\omega$位长的数据时，只会取寄存器`%cl`的低$m$位参与运算，其中$2 ^ m = \omega$。例如当`%cl`中的值是$0xFF$时，`salb`会移动 7 位，`salw`会移动15位，`sall`会移动31位，`salq`会移动63位。

### 特殊的算术操作
称16字节的数为八字`oct word`，Intel 提供了产生两个 64 位数字的全128位乘法以及整数除法的相关指令。

![special operators](_v_images/20210923165830530_17014.png)

注意到指令`imulq`有两种形式：当其有两个操作数时，执行的是64位乘法；当只有一个操作数时，执行的是128位乘法。  
对于除法，不论有无符号都将`%rdx`作为高64位、`%rax`作为低64位组成被除数，将指令的操作数作为除数，并将最终的商存放在`%rax`中，将余数存放在`%rdx`中。

> 特殊指令`cqto`，读出`%rax`的符号位并复制到`%rdx`的所有位。
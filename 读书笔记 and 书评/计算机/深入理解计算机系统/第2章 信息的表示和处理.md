# 第2章 信息的表示和处理

## 指针与字长
每台计算机都有一个字长，用来指明指针数据的标称大小（nominal size），因为虚拟地址是以这样的一个字来编码的。  
字长决定计算机虚拟地址空间的最大大小，字长为 $\omega$，那么虚拟地址范围为 $0 \thicksim 2^\omega - 1$  
64位机器一般也可以运行32位程序。在 `gcc` 中加入 `-m32` 表示指定生成32位程序，`-m64`则是64位。  
> `long` 在大部分32位机器中占4个字节，而在64位机器中占8个字节  
> `char`在大部分机器中是有符号的，但是 C 标准不保证这一点。  
> 使用数据类型 `int32_t` `int64_t`来保证数据大小固定不随编译器和机器变化

## 寻址与字节顺序
最低有效字节在最前面为小端法，最高有效字节在最前面为大端法。  
现代通用处理器同时支持小端法和大端法，具体选择根据操作系统决定。  
在网络协议中，发送方和接收方都需要把数据转化为网络协议格式以避免字节顺序不一致带来的问题。  
文本信息在任何字节顺序的系统上均得到相同的结果，具有更强的平台独立性。

## 位移运算
左移运算`x << k`将x左移k位，丢弃最高的k位，并在右边补k个0。  
右移运算分为两种，逻辑右移和算术右移，两者都是右移，区别是在左端补充的内容，前者是在左端补0，后者是在左边补最高有效位的值。这样设计对有符号整数数据运算有特别意义。  
注意C标准并未对有符号整数应该使用哪种类型的右移作规定，但在几乎所有的机器上都对有符号数算术右移。  
`Java`中对右移有明确规定，`x>>k`表示算数右移，`x>>>k`表示逻辑右移。

## 补码编码
C标准并没有要求要用补码形式来表示有符号数，但是几乎所有的机器都依照补码标准。

## 确定大小的整数
使用`intN_t,uintN_t`这样的声明来定义确定大小的整数类型，如`int32_t, uint64_t`。  
在使用`printf`相关格式打印时，对应的格式串需要扩展宏来保证不论代码在任何机器上编译都能得到正确的效果。如  
```cpp
int32_t x;
uint64_t y;
printf("x = %" PRId32 ",y = %" PRIu64 " "\n", x, y);
```
C预处理器在遇到仅有空格或其它空白字符分割的字符串时，就会把它们串联起来。

## 有符号数和无符号数
C标准并没有规定有无符号的数之间的转化，但一般机器遵循的原则均是按照补码保持底层的位不变。  
在执行运算的时候，若运算数中既有有符号数又有无符号数，C语言会隐式地将有符号数强制转化为无符号数，并假设两者都是非负的。这在`<,>`这类比较运算符中可能导致非直观的效果。

## 数字位的扩展和截断
无符号数在扩展位补0，补码数在扩展位补充原最高有效位。这样定义可以保证补码扩展后值保持不变。  
对于同时改变是否有符号位和数字位的变化，C标准规定，先改变大小，再进行有符号到无符号的转化。比如从`short`到`unsigned`，先进行`(int)`再进行`unsigned`  
不论是否为补码表示，截断则是直接对底层的位进行截断。

## 加法溢出
无符号数：相当于模意义下加法。  
有符号数补码：溢出截断，等价于看作无符号数进行加法。

## 乘法溢出
无论无符号数还是有符号数补码的乘法都是对结果进行截断。  
对于二进制位表示相同的无符号和补码乘法，虽然完整的乘积的位数表示可能不同，但截断之后的结果是相同的。

## 整数除法
定义整数的除法为舍入到零。  
对于除以 2 的幂的情况，当对无符号使用位移运算是很方便的，直接右移即可。  
对于有符号数，正数的情况下也可以直接右移，但是对于负数的情况，需要加上一个偏置 bias 来修正以达到向零舍入，否则直接右移运算是向下舍入。具体而言，对于负数 $x$，用 $(x + (1 << k) - 1) >> k$ 来计算。
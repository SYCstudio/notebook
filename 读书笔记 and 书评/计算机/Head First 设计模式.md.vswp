vnote_backup_file_826537664 D:/notebook/读书笔记 and 书评/计算机/Head First 设计模式.md
# Head First 设计模式

## 第一章 策略模式
策略模式：定义算法族，分别封装起来，让它们之间可以相互替换，让算法的变化独立于使用算法的客户。  
将应用中所有可能需要变化的地方独立出来，取出封装，使这部分以后可以更轻易地改动或扩充，更有弹性。  
针对接口编程，而不是针对实现编程。这里的“接口”指超类型，通常是抽象类或者接口。  
多用组合，少用继承。区分`HAS-A`和`IS-A`。使用组合建立的系统将具有很大的弹性。

## 第二章 观察者模式
观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。  
主题(subject)+观察者(observer)。主题对象管理某些数据，当主题内的数据改变，就会通知注册了的观察者。同时需要维护观察者的注册与取消注册。  
观察者模式使得两个对象之间松耦合，可以彼此交互但不清楚彼此的细节。当某个类需要注册为观察者时，只需要实现对应的观察者接口，再注册为观察者即可。  
> Java 内置的观察者模式  
> 使用`Observable`类追踪所有的观察者并进行通知，使用`Observer`接口实现观察者  
> 应当注意，`Observable`是一个类而不是接口。  
> 由于内部实现顺序，观察者被通知的次序可能与手动实现的不一样。这要求我们不能依赖观察者被通知的次序。  
在传输数据时，既可以让主题将数据推送(push)给观察者，也可以由观察者主动拉(pull)数据

## 第三章 装饰者模式
装饰者模式：动态地将责任附加到对象上，提供了比继承更有弹性的扩展功能。  
类应该对扩展开放，对修改关闭。其目标是允许类容易扩展，这样在不修改现有代码的情况下，就可以搭配新的行为。  
装饰者与被装饰者拥有共同的超类（或接口），使得相应功能可以一层层附加。  
与之对应的，装饰模式的缺点就是在设计中可能会加入大量的小类，提高理解难度。
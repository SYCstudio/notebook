# 第1章 构造过程抽象

计算过程：存在于计算机内的一类抽象事物，去操作被称为**数据**的抽象事物。人们用**程序**来指导这类过程的进行。

使用 Lisp 编程：用 Lisp 表述过程性的思想，对某种特定形式的逻辑表达式（称为递归方程）的使用作推理。最早是一种数学记述形式，提供符号计算的能力并解决一些程序设计问题，包含称为原子和表的数据对象。  
Lisp 的独特特性：计算过程的 Lisp 表述（称为**过程**）本身又可以作为 Lisp 的数据来表示和操作。

## 程序设计的基本元素
一个好的程序设计语言，不仅要能指导计算机进行计算任务，还应该是便于人在其中组织计算过程思想的框架。对于每一种语言，我们将关心以下三个方面：

* 基本表达形式：用于表示语言所关心的最简单的个体
* 组合的方式：从较简单的东西出发构造复合元素
* 抽象的方法：为复合对象命名，并当作一般单元来操作

在程序设计中，我们关注过程和数据这两个元素（实际上这两者并无严格区分）。根据上述的定义，程序设计语言应该提供基本数据和过程的表达，以及对数据和过程进行组合和抽象的方法。

### 表达式
第一种基本表达式是数字，如给 Lisp 一个数 `1`，其解释器会返回 `1`。  
使用括号括起一些表达式，形成一个表来表示过程应用，这样的表达式被称为**组合式**，其基本形式为 `(运算符 运算对象若干)`，如 `(+ 1 2 3)`。这一定义将运算符放在所有运算对象的左边，故被称为**前缀表示**，它能方便地适用于任意个实参的过程。  
组合式的元素本身也可以是组合式，即允许嵌套，如 `(+ (* 1 2) (- 3 4))`。在写很长的组合式时，可以将其中的各个运算对象垂直对齐，以直观地显示出表达式的结构。  

### 命名与环境
任何一种程序设计语言都必须有这样一种设计，即它需要提供一种方式通过名字去使用计算对象。在 Lisp 中，将名字标识称为**变量**，使用 `define` 的方式来定义，如 `(define size 2)`。  
`define` 即是一种最简单的抽象。构造一个复杂的程序就是用逐步的抽象，从简单的对象开始创造更复杂的计算性对象。一个 Lisp 程序通常是由很多相对简单的过程组成的。  
我们可以将值与符号相关联，而后又能从符号中提取出值，这意味着解释器必须提供一种**环境**来存储有关名字-值的关系。环境用于确定表达式中各个符号的意义，它为求值过程的进行提供了一种上下文。

### 组合式的求值
解释器在求解一个组合式时，会进行步骤：

1. 求该组合式的各个子表达式
2. 将作为最左子表达式（运算符）的值的那个过程应用于相应的实际参数，即其它子表达式（运算对象）的值

这一规则从定义上要求对一个组合式的求值过程是**递归**的。我们可以用一棵树的形式来表示组合式的求值过程，而递归是处理这一层次性结构强有力的技术。这种计算过程被称为**树形积累**。运用递归的方式，我们总可以走到求值的某一点是基本表达式，比如数、内部运算符或其它名字，对基本表达式的处理是自然的。我们甚至可以将内部运算符也堪称名字，只需要将像 `+` 和 `*` 一类的运算符也包含在全局环境里，并将相应的指令序列作为与之关联的“值”。

值得注意的是，上述规则中并没有处理定义，即 `(define x 2)` 并不是组合式。这被称为**特殊形式**，后面还会接触到其它特殊形式，每个特殊形式都有其自身的求值规则。Lisp 有着比较简单的语法，对各种表达式的求值规则可以描述为一个简单的通用规则和一组少量特殊形式的规则。

### 复合过程
**过程定义**是对操作的抽象，它为复合操作提供名字，然后我们就可以将这一操作作为单元来使用。其一般形式为 `(define (<name> <formal parameters>) <body>)`，比如计算平方的过程定义可以是 `(define (square x) (* x x))`。  
解释器在解释复合过程时，也是按照一般组合式的求值办法来计算，即首先对组合式的各个元素求值，然后将得到的过程应用于实际参数。  
将复合过程应用于实际参数，就是将过程体中的每个形参用相应的实参取代之后，对这一过程体求值。这一过程被称为**代换模型**。值得强调的是，代换仅仅是帮助我们理解过程调用的情况，而不是对解释器实际工作方式的具体描述，实际上，通常的解释器采用提供形式参数的局部环境的方式。  
从原理上，解释器有两种方式来对表达式求值，我们称之为**应用序**和**正则序**，前者先求值而后应用，后者先完全展开而后归约。可以证明，对于那些可以通过替换去模拟并能产生出合法值的过程应用，两种序将得到相同的值。但也有不同的例子，这些例子可以用来检测解释器究竟是使用哪种方式来求值。在这里，Lisp 采用应用序求值，部分因为这样可以避免对表达式的重复求值从而提高效率。更重要的原因是，当超出了能采用替换的方式模拟的范围后，正则序的处理会变得更复杂。

### 条件表达式和谓词
在 Lisp 中针对分情况分析的特殊形式，有特殊语法 `cond`，其形式如下：

```lisp
(cond (<p1> <e1>)
      (<p2> <e2>)
      ...
      (else <en>))
```

其中最后的 `else` 是可选的。这一定义中，首先包含符号 `cond`，后面跟着若干**子句**表达式对偶。每个对偶的第一个表达式是**谓词**，其值被解释为真或假。  
条件表达式求值时，首先求谓词 `p1` 如果是 `false` 则求 `p2` 一直进行直到某个谓词的值为 `true`，此时解释器返回对应子句中**序列表达式**`e` 的值，以这个值作为整个条件表达式的值。  
谓词可以是基本谓词`< = >`，也可以是逻辑复合运算符`and or not`，其中前两个是短路的，比如对于 `and` 解释器从左至右一个个求值，如果遇到一个假，那么后面的表达式便不再求值。由于 `and or` 的子表达式不一定都求值，所以这两个都是特殊形式而不是普通的过程。

> 注：在 `Scheme` 中存在两个特殊值 `#t, #f`，当解释器检查谓词的值时，将 `#f` 解释为假，其它的解释为真。为方便理解，这里用 `true` 和 `false` 代替，分别关联 `#t` 和 `#f`。

另外一种特殊形式是 `if`，它是条件表达式的一种受限形式，适用于仅有两种情况时，其定义为 `(if <predicate> <consequent> <alternative>)`，首先求值 `<predicate>`，若为真则求值 `<consequent>` 并返回否则求值 `<alternative>`并返回。

### 过程作为黑箱抽象
过程定义隐去了实现的细节，过程的使用者可以不必弄清楚具体的实现，只需要当作一个黑箱来使用。

为保持黑箱的功能，即不影响外部环境，过程的形式参数发挥了重要作用。形式参数的具体名字是什么与其功能无关，这样的名字被称为**约束变量**，一个过程的定义**约束**了它的所有形式参数。反之，如果一个变量不是被约束的，则称其是自由的。

在构造复杂过程时，我们可能会需要构造很多子过程来辅助，很多时候，这些子过程只是在这一复杂过程中使用，为防止与其它复杂过程中的子过程重名，可以采用过程局部化的方式，将子过程放置在嵌套的块中，比如：

```lisp
(define (sqrt x)
    (define (good-enough? guess x)
        (< abs (- (square guess) x)) 0.001))
    (define (improve guess x)
        (average guess (/ x guess)))
    (define (sqrt-iter guess x)
        (if (good-enough? guess x)
            guess
            (sqrt-iter (improve guess x) x)))
    (sqrt-iter 1.0 x))
```

这样定义在**内部块**中就能将名字包装在内部。这一方法的另一好处是，可以通过改变约束情况来简化调用。比如在上例中的 `x`，其定义域约束在 `sqrt` 内，而内部的 `good-enough improve sqrt-iter` 等函数也都在内，那么就不必要显式地在这些函数之间传递了，可以让 `x` 称为内部定义中的自由变量。这一方法被称为**词法作用域**，要求过程中的自由变量实际引用外围定义中所出现的约束，即应该在定义本过程的环境中去寻找。

```lisp
(define (sqrt x)
    (define (good-enough? guess)
        (< abs (- (square guess) x)) 0.001))
    (define (improve guess)
        (average guess (/ x guess)))
    (define (sqrt-iter guess)
        (if (good-enough? guess)
            guess
            (sqrt-iter (improve guess))))
    (sqrt-iter 1.0))
```
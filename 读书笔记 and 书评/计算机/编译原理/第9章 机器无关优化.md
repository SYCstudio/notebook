# 第9章 机器无关优化

本章考虑的是全局代码优化问题，即考虑多个基本块。  
大部分全局优化方法是基于数据流分析技术实现的：对于程序中的每个指令，描述该指令每次执行时必然成立的一些性质。

## 优化的主要来源

编译优化必须保持源程序的语义。所以，通常编译器只能应用一些相对低层的语义转换。  
冗余：通常是高级程序设计语言的副产物（比如高层数据结构的访问，高维数组）。 

下面是一个例子：

快速排序算法：

![](vx_images/258474923302950.png)

对应的直接生成的三地址运算序列及其流图

![](vx_images/473787434530755.png)

![](vx_images/580607368320137.png)

全局公共子表达式优化后（比如 B5 中的 t6, t7, t8, t10 和 B6 中的 t11, t12, t13, t15）：

![](vx_images/470165942591654.png)


公共子表达式消除的同时，可能会引入额外的赋值语句，如下图：

![](vx_images/170626619709532.png)

而赋值语句允许我们使用复制传播进一步优化。  
这里提到了一个观点，当出现赋值语句 `u=v` 后，尽可能用 v 来替代 u，这样能为后面的消除提供机会。  
下面是使用复制传播后，进一步优化的 B5。

![](vx_images/414795408127851.png)

死代码消除：复制传播后，B5 可以进一步使用死代码消除来优化：

![](vx_images/321349316251909.png)

代码移动：主要针对循环，关注循环不变计算，将对它们的求值移动到循环之外，这样就以增加循环外代码的代价，减少了循环内的指令个数。

归纳变量和强度消减：归纳变量即循环中那个每次有规律地递增或递减的值。由于归纳变量是有规律地递增或递减的，所以循环内有关该变量的高代价运算（比如乘法）就可以替换为一个较低代价的运算（比如加法）。另外，如果有一组归纳变量的变化步调一致，我们可以进一步将其规约删减为一个。  
循环的优化处理通常是从里到外的。

下面是一个归纳变量的例子，关注到 B3 中的归纳变量 j 和与其相关的 t4。可以优化如下，注意到在循环入口增加了 t4 的初始赋值：

![](vx_images/114880155040143.png)

进一步的优化可以将 B2, B3, 中的 i,j 全部替换如下

![](vx_images/465201715124033.png)

## 数据流分析简介

数据流抽象：将程序的执行看作是对程序状态的一系列转换。考虑经过一个语句的所有可能路径。一般来说，可能的执行路径也许有无穷多条，跟踪所有的程序状态也是不可能的。所以一般不区分路径之间的差异，也不跟踪整个状态，仅保留进行分析需要的数据。  
在数据流分析模式中，通常将每个**程序点**和一个**数据流值**关联起来。该值即为在该点可能观察到的所有状态的抽象表示。  

数据流问题：定义语句 s 之前和之后的数据流值为 $IN[s]$ 和 $OUT[s]$，数据流问题即是对一组约束求解，该约束限定了语句 s 的 $IN[s]$ 和 $OUT[s]$ 之前的关系。  
约束可以分为两类：基于语句语义（传递函数）的约束和基于控制流的约束。

在基本块上，由于内部的处理通常比较简单，所以可以节约相关分析的空间和时间。类似的，记基本块 B 的数据流值为 IN[B] 和 OUT[B]。

数据流方程通常没有唯一解，故其分析的目标是寻找一个最精确的满足两组约束的解。它能够支持有效的代码改进，但又不会导致不安全的转换。

下面给出几个例子。

### 到达定值

一种常见的数据流模式，当到达程序中的每个点时，每个变量 x 可能在程序中的哪些地方被定值。  
过程参数、数组访问和间接引用都可以有别名，故分析时需要保守。如果我们不知道一个语句是否给 x 赋了一个值，那么必须假定它可能对 x 赋值。本节中我们不考虑别名这样的情况。

传递方程：对于定值 $d: u = v + w$，该语句生成了一个变量 u 的定值 d，其传递函数可以表示为 $f_d(x) = gen_d \cup (x-kill_d)$，其中 $gen_d=\lbrace d \rbrace$，$kill_d$ 是程序中所有其他对 u 的定值。对于基本块的传递方程也是同理。  
控制流方程：对于基本块 B，有 $IN[B] = \bigcup_{P 是 B 的一个前驱基本块} OUT[P]$。  
我们采用迭代的方式来求解，记 $OUT[ENTRY]=\emptyset$，迭代地求解该方程组地最小不动点（即方程其他解所给出地值地子集）。算法流程是不断地向前传播各个定值，直到该定值被杀死。不断重复该过程，直到所有的值收敛。

![](vx_images/713649094188.png)

### 活跃变量分析

对于变量 x 和程序点 p ，x 在点 p 上的值是否会在流图中某条从 p 出发的路径中使用。该信息依赖程序控制流的相反方向进行计算。  
该分析可以用于寄存器分配。

定义 IN[B] 和 OUT[B] 分别为活跃变量集合。$def_B$ 为一个包含变量的集合，这些变量在 B 中的定值（赋值）先于任何使用；$use_B$ 则相反，是可能的使用先于定值。  
方程定义为 $IN[EXIT] = \emptyset$，$IN[B] = use_B \cup (OUT[B] - def_B), OUT[B]=\bigcup_{S 是 B 的后继}IN[S]$。  
使用上一节中迭代算法的类似版本，逆向传播即可求解最小不动点。

### 可用表达式

定义：从流图入口节点到程序点 p 的每条路径都对 x+y 表达式求值，且最后一个求值后没有对 x 或 y 重新赋值，则称 x+y 在 p **可用**。  
如果一个基本块对 x 或 y 赋值且之后没有再重新求 x+y，则称其杀死了表达式 x+y。  
如果一个基本块求 x+y 且之后未修改 x 或 y，则称其生成表达式 x+y。  
该信息主要用于寻找公共子表达式。  
方程为 $OUT[ENTRY]=\emptyset$, $OUT[B]=e\_gen_B \cup (IN[B]-e\_kill_B), IN[B]=\bigcap_{P 是 B 的前缀}OUT[P]$。  
与求解定值中相反的是，这里我们想要得到的是最大可用表达式集合的解，所以是先给出较大的近似值，然后逐步消减。

![](vx_images/54114748150737.png)

### 总结

下表展示了三个例子之间的区别

![](vx_images/410782789637145.png)

# 第3章 词法分析

## 词法分析器的作用
词法分析是编译的第一步，其主要任务是读入源程序的输入字符，组成词素，生成并输出一个词法单元序列，其中每个词法单元对应一个词素。  
词法分析器还负责与符号表交互，将标识符词素添加到符号表中，或者根据符号表中标识符种类的信息确定向语法分析器传送哪个词法单元。  
下图是一个简单的交互流程示意图

![](vx_images/419615010230245.png)

除了识别词素，词法分析器还负责过滤注释和空白、将编译器生成的错误信息与源程序的位置联系起来、宏的扩展等。

### 词法单元、模式和词素

* 词法单元：由词法单元名和可选的属性值组成。  
* 模式：描述了一个词法单元的词素可能具有的形式。  
* 词素：源程序的字符序列，与某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例。  

下表给出了一些常见词法单元的例子

![](vx_images/599395810248671.png)

### 词法单元的属性
词法分析器向语法分析器返回词法单元的名字，以及描述该词法单元的词素的属性值。其中，名字影响语法分析过程中的决定，而属性影响翻译。  
例如对于标识符，我们需要记录词素、类型、第一次出现的位置等信息，这些信息都保存在符号表中，故标识符的属性值可能是一个指向符号表中该标识符对应条目的指针。

### 词法错误
如果没有其它组件的帮助，词法分析器很难发现源代码中的错误。

当所有的词法单元模式都无法和剩余输入的某个前缀匹配时，词法分析器不能继续处理输入，需要一些错误恢复策略。  
最简单的策略是“恐慌模式”恢复，从剩余的输入中不断删除字符，直到词法分析器唔够在剩余输入的开头发现一个正确的词法单元。这一技术可能会给语法分析器带来混乱，但在交互计算环境中已经足够了。另外也有删除、插入、交换、替换字符的方法来尝试进行错误修复。

## 输入缓冲
### 缓冲区对
利用两个交替读入的缓冲区来减少用于处理单个输入字符的时间开销。  
通常而言，每个缓冲区的容量是 N 个字符，N 是磁盘块的大小。系统一次性将 N 个字符读取到缓冲区中，若不足 N 个则使用特殊字符 EOF 标记文件结束。  
维护两个指针：指针 `lexemeBegin` 指向当前词素的开始处，即我们当前正在确定的词素；指针 `forward` 一直向前扫描，直到匹配某个模式。   
在移动 `forward` 指针时，需要检查是否超出了当前缓冲区，如果是则需要更新缓冲区读入新的字符序列。N 的长度需要保证，在识别到词素之前，缓冲区中的数据不会被覆盖。

### 哨兵标记
在上一节的方法中，我们每次移动 `forward` 指针涉及两次判断，一次是判断是否到达缓冲区末尾，一个是确定读入的字符是什么。  
引入一个特殊字符，放到扩展缓冲区的末尾，作为哨兵标记，就可以将两个测试合二为一。

## 词法单元的规约
### 正则表达式
首先给出语言上的一些运算符定义  

![](vx_images/85692014236538.png)

一个语言 L 的 Kleene 闭包记作 $L^*$，即将 L 连接 0 次或多次后得到的串集；定义正闭包 $L^+$ 为 Kleene 闭包不包括 $L^0$ 。注意到 $\epsilon \in L^*$，而除非 $\epsilon \in L$ 否则 $\epsilon \notin L^+$。

正则表达式可以由较小的正则表达式按照一定的规则递归地构建。每个正则表达式 r 表示一个语言 L(r)。给定一个字母表 $\Sigma$，下面给出了定义在其上的正则表达式及其语言的规则

* 归纳基础：$\epsilon$ 是一个正则表达式，且 $L(\epsilon) = \{\epsilon\}$，即该语言仅包含空串；如果 $\alpha$ 是 $\Sigma$ 上的一个符号，那么 $\mathbf a$ 是一个正则表达式，并且 $L(\mathbf a) = \{\alpha\}$  
* 归纳步骤：假定 r,s 都是正则表达式，分别表示语言 L(r) 和 L(s)，那么有如下几种归纳步骤：$(r)|(s), (r)(s), (r)^*, (r)$ 均是正则表达式，且分别表示语言 $L(r)\cup L(s), L(r)L(s), (L(r))^*,L(r)$。

注意到上述表述中可能包含不必要的括号，采用如下的约定去掉一些括号

1. 一元运算符 $*$ 具有最高的优先级，并且是左结合的。  
2. 连接运算优先级次高，并且是左结合的。  
3. $|$ 的优先级最低，并且是左结合的。

可以用正则表达式定义的语言叫做正则集合。  
若两个正则表达式 r 和 s 表示相同的语言，则称 r 和 s 等价，记作 r = s。  
正则表达式遵循一下一些代数定律，每个定律都断言两个具有不同形式的表达式等价

![](vx_images/338433414256704.png)

### 正则表达式的扩展
下面介绍一些被广泛使用的正则表达式的扩展语法

1. 一个或多个实例：类似 $*$ ，单目后缀运算符 $+$ 表示一个正则表达式及其语言的正闭包。  
2. 零个或一个实例：单目后缀运算符 $?$ 表示零个或一个出现，即 $r?$ 等价于 $r | \epsilon$，与运算符 $+$ 和 $*$ 具有相同的优先级和结合性。  
3. 字符类：正则表达式 $a_1 | a_2 | \dots | a _ n$ 可以缩写为 $[a_1a_2\dots a_n]$。进一步的，对于连续的字母、数字可以用第一个和最后一个符号来表示，如 $[a_1-a_n]$。

## 词法单元的识别
这一节中解决根据需要识别的词法单元的模式构造代码的问题。下面是在该节中使用的一个分支语句和条件表达式的简单例子。其文法为

![](vx_images/268695015249373.png)

词法单元模式为

![](vx_images/553225015245928.png)

为了简单起见，关键字作为保留字使用，不能作为标识符。  
另外还引入了一个负责消除空白符的词法单元 $ws \rightarrow (blank | tab | newline)^+$，这一单元不会被返回给语法分析器，而是对这之后的字符进行词法分析。

下表总结了词法分析器的目标。该表总结了，对于词素或词素的集合，应该返回给语法分析器哪个词法单元，以及属性值。

![](vx_images/2905415241682.png)

### 状态转换图
一下是状态转换图的一个示例，表示的是上述例子中与 `relop` 词法单元匹配的词素的状态转换图。

![](vx_images/135651016259562.png)

值得指出的有以下几点：

1. 某些状态被称为接收状态或最终状态，表示已经找到了一个词素。使用双层的圈来表示，并把附加的动作写在后面。  
2. 有些时候，相应的词素并不包含哪个在最后一步使我们到达接收状态的符号，此时需要将 `forward` 回退一个位置。在这样的接受位置的附近加上一个 $*$ 来表示，如果需要回退多步则加上对应个数的 $*$。  
3. 存在一个特殊的状态，被称为开始状态、初始状态。在读入输入符号之前，状态图总是位于开始状态。

正如前面的章节所述，有两种方法来处理保留字和标识符的区别识别。其一是，使用相同的状态转换图，但是提前在符号表中填入保留字，由符号表中的条目知名这些串是否是保留字并指出其代表的词法单元。其二是，为每一个关键字建立单独的状态转换图，若使用这种方法需要注意最后检测后面是非字母或数字，即避免保留字是标识符的前缀的情况，还需要设定词法单元之间的优先级。

合并不同词素的状态转换图可以很好的完成任务，然后我们在其中取最长的和某个模式匹配的词素。但是，由于可能存在相同的开头，使得合并几个词法单元的状态转换图的问题会更加复杂。

## 词法分析器生成工具 Lex

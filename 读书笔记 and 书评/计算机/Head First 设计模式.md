# Head First 设计模式

## 第一章 策略模式
策略模式：定义算法族，分别封装起来，让它们之间可以相互替换，让算法的变化独立于使用算法的客户。  
将应用中所有可能需要变化的地方独立出来，取出封装，使这部分以后可以更轻易地改动或扩充，更有弹性。  
针对接口编程，而不是针对实现编程。这里的“接口”指超类型，通常是抽象类或者接口。  
多用组合，少用继承。区分`HAS-A`和`IS-A`。使用组合建立的系统将具有很大的弹性。

## 第二章 观察者模式
观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。  
主题(subject)+观察者(observer)。主题对象管理某些数据，当主题内的数据改变，就会通知注册了的观察者。同时需要维护观察者的注册与取消注册。  
观察者模式使得两个对象之间松耦合，可以彼此交互但不清楚彼此的细节。当某个类需要注册为观察者时，只需要实现对应的观察者接口，再注册为观察者即可。  
> Java 内置的观察者模式  
> 使用`Observable`类追踪所有的观察者并进行通知，使用`Observer`接口实现观察者  
> 应当注意，`Observable`是一个类而不是接口。  
> 由于内部实现顺序，观察者被通知的次序可能与手动实现的不一样。这要求我们不能依赖观察者被通知的次序。  
在传输数据时，既可以让主题将数据推送(push)给观察者，也可以由观察者主动拉(pull)数据

## 第三章 装饰者模式
装饰者模式：动态地将责任附加到对象上，提供了比继承更有弹性的扩展功能。  
类应该对扩展开放，对修改关闭。其目标是允许类容易扩展，这样在不修改现有代码的情况下，就可以搭配新的行为。  
装饰者与被装饰者拥有共同的超类（或接口），使得相应功能可以一层层附加。  
与之对应的，装饰模式的缺点就是在设计中可能会加入大量的小类，提高理解难度。

## 第四章 工厂模式
工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的是哪一个，工厂方法让类把实例化推迟到子类，即封装具体类型的实例化。  
简单工厂：设立独立的工厂类负责具体的对象生成，使需要创建对象的类不需要关心创建的细节，并能方便地控制生成不同的类。  
让子类决定该创建的对象是什么，通常包括创建者类和产品类。创建者超类定义抽象的工厂方法，包含依赖子类的代码，让子类实现该方法以制造产品。产品类则包括一个产品超类和继承的具体子产品类。  
参数化工厂方法：根据传入的参数创建不同的对象。  
依赖倒置原则：要依赖抽象，不要依赖具体类。低层组件依赖高层的抽象。  
> 变量不可以持有具体类的引用  
> 不要让类派生自具体类  
> 不要覆盖基类中已经实现的方法  
抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。抽象工厂为产品家族提供接口，允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么。  
> 工厂方法与抽象工厂  
> 工厂方法通过子类来创建对象，客户只需要知道所使用的抽象类型，而由子类来负责决定具体类型。  
> 抽象工厂提供一个用来创建产品家族的抽象类型。